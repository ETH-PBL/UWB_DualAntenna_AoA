/*
 * application_config.h
 *
 *  Created on: Jun 27, 2022
 *      Author: tobias
 */

#ifndef SRC_APPS_APPLICATION_CONFIG_H_
#define SRC_APPS_APPLICATION_CONFIG_H_

#include "deca_device_api.h"

/* Communication configuration (enabling STS mode 1 makes this incompatible with the DW1000!). */
static dwt_config_t config = {
    5,                /* Channel number. */
	DWT_PLEN_64,      /* Preamble length. Used in TX only. */
    DWT_PAC8,         /* Preamble acquisition chunk size. Used in RX only. */
    9,                /* TX preamble code. Used in TX only. */
    9,                /* RX preamble code. Used in RX only. */
    0,                /* 0 to use standard 8 symbol SFD, 1 to use non-standard 8 symbol, 2 for non-standard 16 symbol SFD and 3 for 4z 8 symbol SDF type */
    DWT_BR_6M8,       /* Data rate. */
    DWT_PHRMODE_STD,  /* PHY header mode. */
    DWT_PHRRATE_STD,  /* PHY header rate. */
    (65 + 8 - 8),     /* SFD timeout (preamble length + 1 + SFD length - PAC size). Used in RX only. */
    DWT_STS_MODE_1 | DWT_STS_MODE_SDC,   /* STS directly after SFD and supporting data (STS Mode 1). Deterministic (insecure) STS. */
    DWT_STS_LEN_128,  /* STS length (needs to be a multiple of 128 to support more accurate PDoA mode 3 */
	DWT_PDOA_M3       /* PDOA mode 3 */
};

// Frame format based on IEEE Std. 802.15.4-2020 and ISO/IEC 24730-62:2013
typedef struct
{
	uint8_t frame_control[2];	// Frame Control field (c.f. ISO/IEC 24730-62:2013 p. 35f)
	uint8_t sequence_number;	// Data Sequence Number (DSN)
	uint8_t pan_id[2];			// PAN ID (for ISO/IEC 24730-62:2013 TWR this should be 0x609A
	uint8_t dst_address[2];		// Destination address (short address mode)
	uint8_t src_address[2];		// Source address (short address mode)
	uint8_t twr_function_code;	// Fuction code (borrowing from ISO/IEC 24730-62:2013, but this implementation is not standard conforming!)
//	uint8_t payload[...];		// Data payload
//	uint8_t fcs[2];				// Frame Check Sequence (FCS) (automatically generated by the DW3000)
} twr_base_frame_t;

typedef struct
{
	uint8_t frame_control[2];			// Frame Control field (c.f. ISO/IEC 24730-62:2013 p. 35f)
	uint8_t sequence_number;			// Data Sequence Number (DSN)
	uint8_t pan_id[2];					// PAN ID (for ISO/IEC 24730-62:2013 TWR this should be 0x609A
	uint8_t dst_address[2];				// Destination address (short address mode)
	uint8_t src_address[2];				// Source address (short address mode)
	uint8_t twr_function_code;			// Fuction code (borrowing from ISO/IEC 24730-62:2013, but this implementation is not standard conforming!)
	uint8_t poll_resp_round_time[5];	// Time from TX of poll to RX of response frame (i.e. Tround1)
	uint8_t resp_final_reply_time[5];	// Time from RX of response to TX of final frame (i.e. Treply2)
	/* According to ISO/IEC 24730-62:2013 we should send 32-bit timestamps for tx of poll, rx of response
	 * and tx of final frames. This makes not much sense in our case. We can locally compute the roundtrip
	 * and response time to send only two timestamps and we should make use of the full precision of the UWB
	 * chip, hence the timestamps transmitted should be 40-bit.
	 */
//	uint8_t fcs[2];				// Frame Check Sequence (FCS) (automatically generated by the DW3000)
} twr_final_frame_t;


/* Binary measurement data structures */

typedef struct
{
	// Version 3
	uint32_t	cia_diag_1;		// Diagnostics common to both sequences (undocumented CIA_DIAG_1 register)
	uint16_t	ip_poa;			// Preamble POA
	uint16_t	sts1_poa;		// POA of STS block 1
	uint16_t	sts2_poa;		// POA of STS block 2
	int16_t		pdoa;			// PDoA from two STS POAs signed int [1:-11] in radians
	int16_t		xtal_offset;	// Estimated xtal offset of remote device
	int16_t		sts_qual_index;	// STS quality value
	uint8_t		sts_qual;		// STS quality indicator
	uint8_t		tdoa_sign;		// TDoA is a signed 41-bit integer, store the sign bit here
	uint8_t		tdoa[5];		// TDoA from two STS RX timestamps (40-bit without sign)
	uint8_t		ip_toa[5];		// Preamble/Ipatov RX timestamp
	uint8_t		ip_toast;		// RX status of preamble
	uint8_t		sts1_toa[5];	// STS RX timestamp on antenna 1
	uint8_t		sts1_toast;		// RX status of STS on antenna 1 (only high 8-bits, discarding reserved bit 23 in the register)
	uint8_t		sts2_toa[5];	// STS RX timestamp on antenna 2
	uint8_t		sts2_toast;		// RX status of STS on antenna 2 (only high 8-bits, discarding reserved bit 23 in the register)
	uint8_t		fp_th_md;		// First path threshold test mode
	uint8_t		dgc_decision;	// DGC decision index (used for RSSI estimation)
	uint8_t		padding[1];		// 43 bytes of data, padded to multiple of 4 (because of uint32_t)
} meas_time_poa_t;  // with padding 44 bytes


typedef struct
{
	// Version 1
	uint32_t	peak;			// index and amplitude of peak sample in CIR
	uint32_t	power;			// channel area allows estimation of channel power (note: 32-bit for preamble, 16-bit for STS)
	uint32_t	F1;				// F1
	uint32_t	F2;				// F2
	uint32_t	F3;				// F3
	uint16_t	fp_index;		// First path index
	uint16_t	accum_count;	// Number accumulated symbols
} meas_cir_analysis_t;  // 24 bytes, no padding required


typedef struct
{
	// Version 2
	uint64_t	Treply1;		// Tag: tx response - rx poll
	uint64_t	Treply2;		// Anchor: tx final - rx response
	uint64_t	Tround1;		// Anchor: rx response - tx poll
	uint64_t	Tround2;		// Tag: rx final - tx response
	uint32_t	dist_mm;		// Estimated distance in mm
	uint16_t	twr_count;		// Counter of TWR ranging exchanges
	uint16_t	rotation;		// Rotation in degrees from initial position
} meas_twr_t;  // 40 bytes, no padding required

#endif /* SRC_APPS_APPLICATION_CONFIG_H_ */
